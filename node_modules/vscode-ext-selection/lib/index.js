"use strict";
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Alessandro Fragnani. All rights reserved.
*  Licensed under the MIT License. See License.md in the project root for license information.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
var vscode_1 = require("vscode");
function selectWordAtCursorPosition(editor) {
    if (!editor.selection.isEmpty) {
        return true;
    }
    var cursorWordRange = editor.document.getWordRangeAtPosition(editor.selection.active);
    if (!cursorWordRange) {
        return false;
    }
    var newSe = new vscode_1.Selection(cursorWordRange.start.line, cursorWordRange.start.character, cursorWordRange.end.line, cursorWordRange.end.character);
    editor.selection = newSe;
    return true;
}
exports.selectWordAtCursorPosition = selectWordAtCursorPosition;
function selectLines(editor, lines) {
    editor.selections.shift();
    var selections = new Array();
    lines.forEach(function (line) {
        selections.push(new vscode_1.Selection(line, 0, line, editor.document.lineAt(line).text.length));
    });
    editor.selections = selections;
    return editor.selections;
}
exports.selectLines = selectLines;
var Directions;
(function (Directions) {
    Directions[Directions["Forward"] = 0] = "Forward";
    Directions[Directions["Backward"] = 1] = "Backward";
})(Directions || (Directions = {}));
exports.Directions = Directions;
function expandSelectionToPosition(editor, position, direction) {
    var newSelection;
    var actualSelection = editor.selection;
    // no matter 'the previous selection'. going FORWARD will become 'isReversed = FALSE'
    if (direction === Directions.Forward) {
        if (actualSelection.isEmpty || !actualSelection.isReversed) {
            newSelection = new vscode_1.Selection(editor.selection.start.line, editor.selection.start.character, position.line, position.character);
        }
        else {
            newSelection = new vscode_1.Selection(editor.selection.end.line, editor.selection.end.character, position.line, position.character);
        }
    }
    else { // going BACKWARD will become 'isReversed = TRUE'
        if (actualSelection.isEmpty || !actualSelection.isReversed) {
            newSelection = new vscode_1.Selection(editor.selection.start.line, editor.selection.start.character, position.line, position.character);
        }
        else {
            newSelection = new vscode_1.Selection(editor.selection.end.line, editor.selection.end.character, position.line, position.character);
        }
    }
    editor.selection = newSelection;
    return editor.selection;
}
exports.expandSelectionToPosition = expandSelectionToPosition;
function shrinkSelectionToPosition(editor, position, direction) {
    var newSelection;
    // no matter 'the previous selection'. going FORWARD will become 'isReversed = FALSE'
    if (direction === Directions.Forward) {
        newSelection = new vscode_1.Selection(editor.selection.end.line, editor.selection.end.character, position.line, position.character);
    }
    else { // going BACKWARD , select to line length
        newSelection = new vscode_1.Selection(editor.selection.start.line, editor.selection.start.character, position.line, position.character);
    }
    editor.selection = newSelection;
    return editor.selection;
}
exports.shrinkSelectionToPosition = shrinkSelectionToPosition;
//# sourceMappingURL=index.js.map