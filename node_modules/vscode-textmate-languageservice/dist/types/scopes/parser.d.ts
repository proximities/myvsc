import * as matchers from './matchers';
export interface FilePosition {
    offset: number;
    line: number;
    column: number;
}
export interface FileRange {
    start: FilePosition;
    end: FilePosition;
    source: string;
}
export interface LiteralExpectation {
    type: 'literal';
    text: string;
    ignoreCase: boolean;
}
export type ClassParts = Array<string | ClassParts>;
export interface ClassExpectation {
    type: 'class';
    parts: ClassParts;
    inverted: boolean;
    ignoreCase: boolean;
}
export interface AnyExpectation {
    type: 'any';
}
export interface EndExpectation {
    type: 'end';
}
export interface OtherExpectation {
    type: 'other';
    description: string;
}
export type Expectation = LiteralExpectation | ClassExpectation | AnyExpectation | EndExpectation | OtherExpectation;
declare class _PeggySyntaxError extends Error {
    static buildMessage(expected: Expectation[], found: string | null): string;
    message: string;
    expected: Expectation[];
    found: string | null;
    location: FileRange;
    name: string;
    constructor(message: string, expected: Expectation[], found: string | null, location: FileRange);
    format(sources: Array<{
        source?: any;
        text: string;
    }>): string;
}
export interface TraceEvent {
    type: string;
    rule: string;
    result?: any;
    location: FileRange;
}
export interface ParseOptions {
    filename?: string;
    startRule?: 'start';
    tracer?: any;
    [key: string]: any;
}
export type ParseFunction = <Options extends ParseOptions>(input: string, options?: Options) => Options extends {
    startRule: infer StartRule;
} ? (StartRule extends 'start' ? Start : Start) : Start;
export declare const parse: ParseFunction;
export declare const PeggySyntaxError: typeof _PeggySyntaxError;
export type PeggySyntaxError = _PeggySyntaxError;
export type Start = matchers.ParsedMatcher;
export type Atom = matchers.AtomMatcher;
export type Scope = matchers.ScopeMatcher;
export type Path = matchers.PathMatcher;
export type Group = matchers.GroupMatcher;
export type Expression = matchers.ExpressionMatcherType;
export type Composite = matchers.CompositeMatcherType;
export type Selector = matchers.ParsedMatcher;
export type _ = Array<' ' | '	'>;
export {};
